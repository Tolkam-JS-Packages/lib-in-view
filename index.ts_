import Context, { TEventHandler } from './Context';
import Subject from './Subject';

/**
 * Class for tracking element visibility relative to it's scrolling parent
 *
 */
export default class InView {

    /**
     * Context instance
     * @type {Context}
     */
    public readonly context: Context;

    /**
     * Subject instance
     * @type {Subject}
     */
    public readonly subject: Subject;

    /**
     * Options
     * @type {IOptions}
     */
    protected options: IOptions;

    /**
     * Context events callback
     * @type {ICallback}
     */
    protected callback: ICallback;

    /**
     * @param {HTMLElement} element
     * @param {ICallback}   callback
     * @param {IOptions}    options
     */
    public constructor(
        element: HTMLElement,
        callback: ICallback,
        options: IOptions = {}
    ) {
        // default options
        options = this.options = {
            windowEvents: ['DOMContentLoaded', /*'load',*/ 'resize'], // do we need two load events?
            ...options,
        };

        const contextElement = options.context || element.ownerDocument.defaultView;
        const context = new Context(contextElement);

        this.subject = new Subject(element);
        this.context = context;
        this.callback = callback;

        // start listening by default
        context.listen(this.eventsHandler, options.windowEvents);
    }

    /**
     * Stops listening of context events
     *
     */
    public stop() {
        this.context.unlisten(this.eventsHandler);
    }

    /**
     * Handles context events
     */
    protected eventsHandler = () => {
        const { subject, context, options, withOffset } = this;
        const offset = options.offset || {};

        // stop if scrolled less than defined minimum pixels
        const scrollAmount = options.scrollAmount || {top: 0, left: 0};
        const scrollTopDiff = Math.abs(context.scrollTopDiff());
        const scrollLeftDiff = Math.abs(context.scrollLeftDiff());

        if (
            (scrollTopDiff > 0 && scrollTopDiff <= scrollAmount.top!)
            || (scrollLeftDiff > 0 && scrollLeftDiff <= scrollAmount.left!)
        ) {
            return;
        }

        const cHeight = context.innerHeight();
        const cWidth = context.innerWidth();
        const cSTop = context.scrollTop();
        const cSLeft = context.scrollLeft();

        const cTop = context.top();
        const cLeft = context.left();
        const cBottom = cTop + cHeight;
        const cRight = cLeft + cWidth;

        const eTop = withOffset(subject.top(), offset.top);
        const eLeft = withOffset(subject.left(), offset.left);
        const eBottom = withOffset(subject.bottom(), offset.bottom, -1);
        const eRight = withOffset(subject.right(), offset.right, -1);

        const topVisible = eTop >= cTop && eTop < cBottom;
        const bottomVisible = eBottom < cBottom && eBottom >= cTop;
        const leftVisible = eLeft >= cLeft && eLeft < cRight;
        const rightVisible = eRight < cRight && eRight >= cLeft;

        this.callback({
            topLeft: topVisible && leftVisible,
            topRight: topVisible && rightVisible,
            bottomLeft: bottomVisible && leftVisible,
            bottomRight: bottomVisible && rightVisible,
        });
    };

    /**
     * Returns subject dimension taking offset in account
     *
     * @param {number} value
     * @param {TOffset} offset
     * @param {number} operand
     */
    protected withOffset = (value: number, offset: TOffset = 0, operand: 1 | -1 = 1): number => {
        let result = value;

        if (typeof offset === 'number') {
            result += offset as number * operand;

        } else if (typeof offset === 'function') {
            result += offset.call(this, this.subject, this.context) * operand;

        }

        return result;
    }
}

export interface IOptions {

    // Scrolling parent element, defaults to window
    context?: HTMLElement;

    // window events to listen to besides context's scroll event
    windowEvents?: string[];

    // Subject element detection offset
    offset?: IOffset;

    // minimum scrolled pixels to consider as change
    scrollAmount?: IScrollAmount;
}

export interface IVisibility {
    topLeft: boolean;
    topRight: boolean;
    bottomLeft: boolean;
    bottomRight: boolean;
}

export type ICallback = (visibility: IVisibility) => void;

export type TOffset = number|((subject: Subject, context: Context) => number);

export interface IOffset {
    top?: TOffset;
    left?: TOffset;
    right?: TOffset;
    bottom?: TOffset;
}

export interface IScrollAmount {
    top?: number;
    left?: number;
}
